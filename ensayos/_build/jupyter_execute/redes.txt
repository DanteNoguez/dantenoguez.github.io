!pip install matplotlib --upgrade

import math
import matplotlib.pyplot as plt
import numpy as np

class Numero:
  def __init__(self, valor, _previos=(), _op='', etiqueta=''):
    self.valor = valor
    self._previos = set(_previos)
    self._op = _op
    self.etiqueta = etiqueta

  def __add__(self, otro): # adición
    otro = otro if isinstance(otro, Numero) else Numero(otro) # nos cercioramos de que el otro valor sea un Número
    resultado = Numero(self.valor + otro.valor, (self, otro), '+')
    return resultado

  def __radd__(self, otro): # en Python, debemos apoyarnos de una función extra (con prefijo r) para casos en los que la función anterior no funcione
    return self + otro

  def __mul__(self, otro): # multiplicación
    otro = otro if isinstance(otro, Numero) else Numero(otro)
    resultado = Numero(self.valor * otro.valor, (self, otro), '*')
    return resultado

  def __rmul__(self, otro):
    return self * otro

  def __sub__(self, otro): # resta, substracción
    return self + (-otro)

  def __rsub__(self, otro):
    return otro + (-self)

  def __pow__(self, otro):
    assert isinstance(otro, (int, float))
    resultado = Numero(self.valor**otro, (self,), f'**{otro}')
    return resultado

  def __truediv__(self, otro): # división
    return self * otro**-1 #dividir es lo mismo que multiplicar por el dividendo elevado a la menos 1
  
  def __rtruediv__(self, otro):
    return otro * self**-1

  def __neg__(self): # volver negativo un número
    return self * -1

  def __repr__(self):
    return f'Valor={self.valor}' # esta función determina cómo se representa nuestro número


a = Numero(2, etiqueta='a') # definimos dos Números: a y b
b = Numero(5, etiqueta='b')
c = a*b # definimos c, que es el resultado de multiplicar a y b

print(f'{c} | Valores previos: {c._previos}, | Operación realizada para generar c: {c._op}')

from graphviz import Digraph

def rastreo(origen):
  # construye un conjunto de todos los nodos en un gráfico
  nodos, lineas = set(), set()
  def construir(v):
    if v not in nodos:
      nodos.add(v)
      for parte in v._previos:
        lineas.add((parte, v))
        construir(parte)
  construir(origen)
  return nodos, lineas

def graficar(origen):
  grafica = Digraph(format='svg', graph_attr={'rankdir': 'LR'}) # left to right, izquierda a derecha

  nodos, lineas = rastreo(origen)
  for n in nodos:
    uid = str(id(n))
    # por cada valor en la grafica, crea un nodo rectangular ('record') para él
    grafica.node(name=uid, label='{ %s | valor %.4f}' % (n.etiqueta, n.valor), shape='record')
    if n._op:
      # si el valor es resultado de una operación, crea un nodo para la operación
      grafica.node(name = uid + n._op, label = n._op)
      # conecta los nodos
      grafica.edge(uid + n._op, uid)

  for n1, n2 in lineas:
    # conecta n1 al nodo operación de n2
    grafica.edge(str(id(n1)), str(id(n2)) + n2._op)

  return grafica

c.etiqueta = 'c'
graficar(c)

a2 = np.arange(0, 13, 2)
def f(a): return a*5
b2 = f(a2)

fig, ax = plt.subplots(figsize=(10, 7))
ax.plot(a2, b2, marker='o', color='blue') 
ax.set_facecolor('black')
ax.set_xlabel('Valores de a')
ax.set_ylabel('Valores de b')
plt.show()

import pandas as pd
d = {'Valores de a': a2, 'Valores de b': b2}
tabla = pd.DataFrame(data=d)
tabla = tabla.style.hide_index()
tabla

a2 = np.arange(0, 13, 2)
def f(a): return a*5
b2 = f(a2)

derivada = (b2[2] - b2[1]) / (a2[2] - a2[1])

fig, ax = plt.subplots(figsize=(10, 7))
ax.plot(a2, b2, marker='o', color='blue', label='recta de la función') 
ax.set_facecolor('black')
ax.set_xlabel('Valores de a')
ax.set_ylabel('Valores de b')
ax.axline((a2[1], b2[1]), slope=derivada, color='red', label='pendiente') # <- Aquí está definida la derivada
ax.hlines(y=10, xmin=0, xmax=2, linewidth=1, color='white', linestyles='dashed')
ax.vlines(x=2, ymin=0, ymax=10, linewidth=1, color='white', linestyles='dashed')
ax.legend()
plt.show()

# Supongamos que quiero medir la distancia que recorro en 20 segundos:
# Si con el paso de tiempo no avanzo o, lo que es lo mismo,
# si mi variable tiempo no influye en la función distancia, entonces mi función y mi derivada lucen así:

tiempo = np.arange(0, 21, 1)
def f(t): return t*0
distancia = f(tiempo)

fig, ax = plt.subplots(figsize=(10, 7))
ax.plot(tiempo, distancia, marker='o', color='blue', label='recta de la función') 
ax.set_facecolor('black')
ax.set_xlabel('Tiempo (segundos)')
ax.set_ylabel('Distancia (metros)')
ax.axline((tiempo[0], distancia[0]), slope=0, color='red', label='Pendiente')
ax.legend()
plt.show()

x = np.arange(0, 13, 2)
def f(x): return x+6
y = f(x)

z = {'Valores de x': x, 'Valores de y': y}
tabla = pd.DataFrame(data=z)
tabla = tabla.style.hide_index()
tabla

derivada = (y[2] - y[1]) / (x[2] - x[1])

fig, ax = plt.subplots(figsize=(10, 7))
ax.plot(x, y, marker='o', color='blue', label='recta de la función') 
ax.set_facecolor('black')
ax.set_xlabel('Valores de x')
ax.set_ylabel('Valores de y')
ax.axline((x[1], y[1]), slope=derivada, color='red', label='pendiente') # <- Aquí está definida la derivada
ax.hlines(y=10, xmin=0, xmax=4, linewidth=1, color='white', linestyles='dashed')
ax.vlines(x=4, ymin=0, ymax=10, linewidth=1, color='white', linestyles='dashed')
ax.legend()
plt.show()

def pendiente(x, y, j, i):
  return (y[j] - y[i]) / (x[j] - x[i])

pendiente(x, y, 2, 1)

def derivada(x, f, i):
  h = 0.000001
  return (f(x[i]+h) - f(x[i])) / h

derivada(x, f, 2)
