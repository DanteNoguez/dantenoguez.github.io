!pip install matplotlib --upgrade

import math
import matplotlib.pyplot as plt
import numpy as np

class Numero:
  def __init__(self, valor, _previos=(), _op='', etiqueta=''):
    self.valor = valor
    self._previos = set(_previos)
    self._op = _op
    self.etiqueta = etiqueta

  def __add__(self, otro): # adición
    otro = otro if isinstance(otro, Numero) else Numero(otro) # nos cercioramos de que el otro valor sea un Número
    resultado = Numero(self.valor + otro.valor, (self, otro), '+')
    return resultado

  def __radd__(self, otro): # en Python, debemos apoyarnos de una función extra (con prefijo r) para casos en los que la función anterior no funcione
    return self + otro

  def __mul__(self, otro): # multiplicación
    otro = otro if isinstance(otro, Numero) else Numero(otro)
    resultado = Numero(self.valor * otro.valor, (self, otro), '*')
    return resultado

  def __rmul__(self, otro):
    return self * otro

  def __sub__(self, otro): # resta, substracción
    return self + (-otro)

  def __rsub__(self, otro):
    return otro + (-self)

  def __pow__(self, otro):
    assert isinstance(otro, (int, float))
    resultado = Numero(self.valor**otro, (self,), f'**{otro}')
    return resultado

  def __truediv__(self, otro): # división
    return self * otro**-1 #dividir es lo mismo que multiplicar por el dividendo elevado a la menos 1
  
  def __rtruediv__(self, otro):
    return otro * self**-1

  def __neg__(self): # volver negativo un número
    return self * -1

  def __repr__(self):
    return f'Valor={self.valor}' # esta función determina cómo se representa nuestro número


a = Numero(2, etiqueta='a') # definimos dos Números: a y b
b = Numero(5, etiqueta='b')
c = a*b # definimos c, que es el resultado de multiplicar a y b

print(f'{c} | Valores previos: {c._previos}, | Operación realizada para generar c: {c._op}')

from graphviz import Digraph

def rastreo(origen):
  # construye un conjunto de todos los nodos en un gráfico
  nodos, lineas = set(), set()
  def construir(v):
    if v not in nodos:
      nodos.add(v)
      for parte in v._previos:
        lineas.add((parte, v))
        construir(parte)
  construir(origen)
  return nodos, lineas

def graficar(origen):
  grafica = Digraph(format='svg', graph_attr={'rankdir': 'LR'}) # left to right, izquierda a derecha

  nodos, lineas = rastreo(origen)
  for n in nodos:
    uid = str(id(n))
    # por cada valor en la grafica, crea un nodo rectangular ('record') para él
    grafica.node(name=uid, label='{ %s | valor %.4f}' % (n.etiqueta, n.valor), shape='record')
    if n._op:
      # si el valor es resultado de una operación, crea un nodo para la operación
      grafica.node(name = uid + n._op, label = n._op)
      # conecta los nodos
      grafica.edge(uid + n._op, uid)

  for n1, n2 in lineas:
    # conecta n1 al nodo operación de n2
    grafica.edge(str(id(n1)), str(id(n2)) + n2._op)

  return grafica

c.etiqueta = 'c'
graficar(c)

a2 = np.arange(0, 13, 2) 
b2 = [5 for i in a2]
def f(a, b): return a*b
c = f(a2, b2)

fig, ax = plt.subplots(figsize=(10, 7))
ax.plot(a2, c, marker='o', color='blue') 
ax.set_facecolor('black')
ax.set_xlabel('Valores de a')
ax.set_ylabel('Valores de b')
plt.show()

import pandas as pd
d = {'Valores de a': a2, 'Valores de b': b2, 'Valores de c': c}
tabla = pd.DataFrame(data=d)
tabla = tabla.style.hide_index()
tabla

deriv = (f(a2+0.00001, b2) - f(a2, b2)) / 0.00001
print(f'Valores de la derivada en cada punto: {deriv}')

fig, ax = plt.subplots(figsize=(10, 7))
ax.plot(a2, c, marker='o', color='blue', label='recta de la función') 
ax.set_facecolor('black')
ax.set_xlabel('Valores de a')
ax.set_ylabel('Valores de c')
ax.axline((a2[1], c[1]), slope=deriv[1], color='red', label='pendiente') # <- La pendiente es la derivada
ax.hlines(y=10, xmin=0, xmax=2, linewidth=1, color='white', linestyles='dashed')
ax.vlines(x=2, ymin=0, ymax=10, linewidth=1, color='white', linestyles='dashed')
ax.legend()
plt.show()

# Supongamos que quiero medir la distancia que recorro en 20 segundos:
# Si con el paso de tiempo no avanzo o, lo que es lo mismo,
# si mi variable tiempo no influye en la función distancia, entonces mi función y mi derivada lucen así:

tiempo = np.arange(0, 21, 1)
def f(t): return t*0
distancia = f(tiempo)

fig, ax = plt.subplots(figsize=(10, 7))
ax.plot(tiempo, distancia, marker='o', color='blue', label='recta de la función') 
ax.set_facecolor('black')
ax.set_xlabel('Tiempo (segundos)')
ax.set_ylabel('Distancia (metros)')
ax.axline((tiempo[0], distancia[0]), slope=0, color='red', label='Pendiente')
ax.legend()
plt.show()

x = np.arange(0, 13, 2)
def f(x): return x+6
y = f(x)

z = {'Valores de x': x, 'Valores de y': y}
tabla = pd.DataFrame(data=z)
tabla = tabla.style.hide_index()
tabla

derivada = (y[2] - y[1]) / (x[2] - x[1])

fig, ax = plt.subplots(figsize=(10, 7))
ax.plot(x, y, marker='o', color='blue', label='recta de la función') 
ax.set_facecolor('black')
ax.set_xlabel('Valores de x')
ax.set_ylabel('Valores de y')
ax.axline((x[1], y[1]), slope=derivada, color='red', label='pendiente')
ax.hlines(y=10, xmin=0, xmax=4, linewidth=1, color='white', linestyles='dashed')
ax.vlines(x=4, ymin=0, ymax=10, linewidth=1, color='white', linestyles='dashed')
ax.legend()
plt.show()

xs = np.arange(1, 11, 1)
ys = [3 for i in xs]
def cub(x, y): return x**y
r = cub(xs, ys)

derivs = (cub(xs+0.00001, ys) - cub(xs, ys)) / 0.00001

fig, ax = plt.subplots(ncols=2, figsize=(10, 7))
ax[0].plot(xs, r, marker='o', color='blue', label='gráfica de la función')
ax[0].set_title('Gráfica')
ax[0].set_facecolor('black')
ax[0].set_xlabel('Valores de x')
ax[0].set_ylabel('Valores de r')
ax[0].axline((xs[5], r[5]), slope=derivs[5], color='red', label='tangente')
ax[0].legend()
ax[1].plot(xs, r, marker='o', color='blue', label='gráfica de la función') 
ax[1].set_title('Zoom a la gráfica')
ax[1].set_facecolor('black')
ax[1].set_xlabel('Valores de x')
ax[1].set_ylabel('Valores de r')
ax[1].axline((xs[5], r[5]), slope=derivs[5], color='red', label='tangente')
ax[1].set_xlim(xs[1], xs[7])
ax[1].set_ylim(r[0], 600)
ax[1].legend()
plt.show()

# Tres variables

def ft(x, y, z):
  return x*y + z

def deriv2(x, y, z):
  h = 0.00001
  return (ft(x+h, y, z) - ft(x, y, z)) / h

def deriv3(x, y, z):
  h = 0.00001
  return (ft(x, y, z+h) - ft(x, y, z)) / h

zs = np.arange(10, 111, 10)
len(zs)

deriv2(xs, ys, zs) * deriv3(xs, ys, zs)


